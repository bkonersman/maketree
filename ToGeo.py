#! /usr/bin/env python2.6

import cPickle as pickle
import shelve
import os

#+++++++++++++++++++++++++++++++ATTRIBUTE CLASS  ++++++++++++++++++++++++++++++++++++
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
class Attribute(object):
    '''
        An attribute may be bound to point, primitive, vertex or detail
        elements.  The attribute stores an array of values, one for each
        element in the detail.
        
        Try this: ToGeo instantiates this class for each attribute. The list of attributes is 
        built in to ToGeo.
        
        
        
        
        
        
    '''
    def __init__(self, name, attrib_type, attrib_scope):
        ''' Initialize an attribute of the given name, type and scope '''
        # Data defined in definition block
        self.Name = name
        self.Type = attrib_type
        self.Scope = attrib_scope
        self.Options = {}
        # Data defined in per-attribute value block
        self.TupleSize = 1
        self.Array = []
        self.Defaults = None
        self.Strings = None

""" This reads in my format and writes out a JSON formatted .geo file"""
#----------------------------END ATTRIBUTE CLASS ---------------------------
#-------------------------------------------------------------------------

#+++++++++++++++++++++++++++++++Main Class++++++++++++++++++++++++++++++++++++
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
class ToGeo(object):
    """ Opens a file containing list of attributes, redistributes the date to other
        attributes, and writes it out via JSON to the .geo format."""
    
    def __init__(self, filename = "control.txt"):
        self.attDict = {}
        tmpList = []
        with open(filename) as f:
            start = 0
            for line in f:
                if line =="\n":
                    continue
                if len(line) <= 1:
                    continue
                val = line.split()
                if len(val) <3:
                    continue
                if val[0] == "attNum":
                    attnum = int(val[2])
                    #print( "attnum = ", attnum)
                if val[0] == "elemNum":
                    elemnum = val[2]
                    print( "elemnum = " + str(elemnum))
                if  "start att def" in line:
                    start = 1
                    continue
                if start == 1:
                    name = val[0] #this will be a string
                    self.
                    tmpList.append(val[0])
                    
                #print val[0]
            print tmpList
                        
                    
                
        


    def loadFile(self, filename):
        """loads a pickled data file generated by runTree.py """
        thisFile = open(filename, "rb")
        #myFile = pickle.load(open(filename,"rb"))
        myFile = pickle.load(thisFile)
        self.header = myFile[0]
        self.data = myFile[1]
        thisFile.close()
        
    def save(self):
        ''' Create the JSON schema from the attribute's data '''
        adef = [
            "scope", self.Scope,
            "type", self.Type,
            "name", self.Name,
            "options", self.Options
        ]
        avalue = [
            "size", self.TupleSize,
        ]
        if self.Defaults:
            avalue += [
                "defaults", [
                    "size", len(self.Defaults),
                    "storage", "fpreal64",
                    "values", self.Defaults
                ]
            ]
        if self.Strings:
            avalue += [ "strings", self.Strings ]

        kword = "tuples"
        a = self.Array
        if self.TupleSize == 1:
            kword = "arrays"    # Store tuple of arrays not an array of tuples
            a = [self.Array]
        if self.Type == 'numeric':
            avalue += [ 'storage', self.Storage ]
            avalue += [
                "values", [
                    "size", self.TupleSize,
                    "storage", self.Storage,
                    kword, self.Array
                ]
            ]
        elif self.Type == 'string':
            avalue += [
                "indices", [
                    "size", self.TupleSize,
                    "storage", "int32",
                    kword, self.Array ]
            ]
        else:
            avalue += self.Array
        return [ adef, avalue ]

    def listToDict(L):
        # Since JSON doesn't enforce order for dictionary objects, the geometry
        # schema often stores dictionaries as lists of name/value pairs.  This
        # function will throw the list into a dictionary for easier access.
        if L and type(L) == list:
            d = {}
            for i in xrange(0, len(L), 2):
                d[L[i]] = L[i+1]
            return d
        return L


    def saveJSON(self):
        ''' Create the JSON schema for the detail:  all the attributes,
            primitives, groups.
            For 2D (trim curves), the detail also contains special properties
            for the altitude and trim regions.'''
        #-----------------local variables --------------------------------------
        _VERSION = "runTree_V4"
        self.pointCount = self.TOTAL
        self.vertexCount = self.TOTAL
        self.primitiveCount = 0
        self.VertexMap = []
        self.VertexAttributes = []
        self.PointAttributes = []
        self.PrimitiveAttributes=[]
        self.GlobalAttributes = []
        
        for p in self.allPoints:
            x = p[0]
            self.vertexMap.append(x)
        print "vertexMap = " + str(self.VertexMap)
        
        
        #--------------------------from Houdini---------------------------------
        data = []
        data += [ 'fileversion', _VERSION ]
        data += [ 'pointcount', self.pointCount() ]
        data += [ 'vertexcount', self.vertexCount() ]
        data += [ 'primitivecount', self.primitiveCount() ]
        data += [ 'topology', [ 'pointref', [ 'indices', self.VertexMap ] ] ]
        attribs = []
        attribs += self.saveAttributes('vertexattributes', self.VertexAttributes)
        attribs += self.saveAttributes('pointattributes', self.PointAttributes)
        attribs += self.saveAttributes('primitiveattributes', self.PrimitiveAttributes)
        attribs += self.saveAttributes('globalattributes', self.GlobalAttributes)
        if attribs:
            data += ["attributes", attribs]
        data += self.savePrimitives()
        data += self.saveGroups("pointgroups", "point", self.PointGroups)
        data += self.saveGroups("vertexgroups", "vertex", self.VertexGroups)
        data += self.saveGroups("primitivegroups", "primitive", self.PrimitiveGroups)
        #if hasattr(self, 'Altitude'):
            #data += ["altitude", self.Altitude]
        #if hasattr(self, 'TrimRegions'):
            #regions = []
            #for t in self.TrimRegions:
                #regions.append(t.save())
            #data += ["trimregions", regions]
        return data

    def save(self, fp, indent=None):
            ''' Save the JSON schema to a file '''
            json.dump(self.saveJSON(), fp, indent=indent)

    def _ginfo(filename):
        try:
            fp = open(filename, 'r')
        except:
            print 'Unable to open', filename
            return
        _Verbose('Loading %s' % filename)
        fdata = json.load(fp)
        _Verbose('Done Loading %s' % filename)
        d = Detail()
        d.loadJSON(fdata)
        print '='*10, filename, '='*10
        print '%12d Points' % d.pointCount()
        print '%12d Vertices' % d.vertexCount()
        print '%12d Primitives' % d.primitiveCount()
        print '-'*5, 'Attributes', '-'*5
        _ginfoAttributes('Point', d.PointAttributes)
        _ginfoAttributes('Vertex', d.VertexAttributes)
        _ginfoAttributes('Primitive', d.PrimitiveAttributes)
        _ginfoAttributes('Global', d.GlobalAttributes)
        _ginfoGroups('Point', d.PointGroups)
        _ginfoGroups('Vertex', d.VertexGroups)
        _ginfoGroups('Primitive', d.PrimitiveGroups)
        _ginfoPrimitives(d.Primitives)
        _dumpPrimitive(d, 0)

    def test():
        if len(sys.argv) == 1:
            _ginfo(os.path.expandvars('$HH/geo/defgeo.bgeo'))
        else:
            for f in sys.argv[1:]:
                _ginfo(f)
#=============================TESTING============================

g = ToGeo("control.txt")
g.loadFile("saveData.p")

